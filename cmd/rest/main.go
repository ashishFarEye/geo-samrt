package main

import (
	"geo-smart/api/gen/restapi"
	"geo-smart/api/gen/restapi/operations"
	"geo-smart/cmd/rest/handlers"
	"geo-smart/config"
	"geo-smart/internal/geocodingCompare"
	"geo-smart/internal/geosmart"
	"geo-smart/internal/pkg/platform"
	"geo-smart/internal/pkg/platform/postgres"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-resty/resty/v2"
	"go.elastic.co/apm/module/apmhttp"
	"go.uber.org/zap"
	"log"
	"net/http"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

func main() {

	cfg := config.Init()

	// init logger
	logger, _ := zap.NewProduction()
	defer func() {
		if err := logger.Sync(); err != nil {
			logger.Fatal("couldn't flush zap logger", zap.Error(err))
		}
	}()

	//loads embedded swagger
	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		log.Fatalln(err)
	}

	api := operations.NewGeoSmartAPI(swaggerSpec)
	server := restapi.NewServer(api)
	defer func() {
		err := server.Shutdown()
		if err != nil {
			logger.Fatal("couldn't shutdown server", zap.Error(err))
		}
	}()

	if cfg.Server.Port == 0 {
		cfg.Server.Port = 8080
	}
	server.Port = cfg.Server.Port
	server.Host = cfg.Server.Host

	// Initialize APM client
	apmClient := apmhttp.WrapClient(http.DefaultClient)

	// Initialize Resty with Elastic-APM
	client := resty.NewWithClient(apmClient)


	pelias := platform.NewPelias(cfg.Geocoder.Pelias.Host, client, logger)

	es := platform.NewES(cfg.Geocoder.ES.Host, cfg.Geocoder.ES.User, cfg.Geocoder.ES.Pwd, logger)

	pg := postgres.New(cfg.PG.URL, cfg.PG.Username, cfg.PG.Password, cfg.PG.DB)

	maps := platform.NewMaps(logger, es, pelias)

	api.CheckHealthHandler = operations.CheckHealthHandlerFunc(
		func(health operations.CheckHealthParams) middleware.Responder {
			return operations.NewCheckHealthOK().WithPayload("OK")
		})

	api.GeosmartHandler = handlers.NewGeocoder(geosmart.New(logger,maps), logger)
	api.CompareHandler = handlers.NewGeocoderCompare(geocodingCompare.New(logger,pelias, postgres.NewGeoDB(pg)),logger)

	//parser := flags.NewParser(server, flags.Default)
	//parser.ShortDescription = "GeoSmart"
	//parser.LongDescription = "This project contains APIs for pelias and esmap"
	//server.ConfigureFlags()
	//for _, optsGroup := range api.CommandLineOptionsGroups {
	//	_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
	//	if err != nil {
	//		log.Fatalln(err)
	//	}
	//}
	//
	//if _, err := parser.Parse(); err != nil {
	//	code := 1
	//	if fe, ok := err.(*flags.Error); ok {
	//		if fe.Type == flags.ErrHelp {
	//			code = 0
	//		}
	//	}
	//	os.Exit(code)
	//}

	server.ConfigureAPI()
	// Start listening using having the handlers and port
	// already set up.
	if err := server.Serve(); err != nil {
		logger.Fatal("---Error While Serving---", zap.Error(err))
	}

}
